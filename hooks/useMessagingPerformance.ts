import { useState, useEffect, useCallback, useRef } from 'react';\nimport { \n  MessagingPerformanceOptimizer, \n  PerformanceMetrics, \n  OptimizationConfig,\n  OptimisticMessage,\n  initializePerformanceOptimizer,\n  getPerformanceOptimizer\n} from '../utils/messagingPerformanceOptimizer';\nimport { MessageCache, messageCache } from '../utils/MessageCache';\nimport { Message } from '../types/message';\nimport { ApiResponse } from '../types/messaging';\nimport { useMessagingApi } from './useMessagingApi';\n\nexport interface MessagingPerformanceHookResult {\n  /**\n   * Load messages with performance optimizations\n   */\n  loadMessagesOptimized: (\n    conversationId: string,\n    options?: {\n      useCache?: boolean;\n      enableOptimistic?: boolean;\n      batchKey?: string;\n    }\n  ) => Promise<Message[]>;\n  \n  /**\n   * Send message with optimistic updates\n   */\n  sendMessageOptimistic: (\n    message: Omit<Message, '_id' | 'createdAt'>\n  ) => Promise<Message>;\n  \n  /**\n   * Retry failed optimistic message\n   */\n  retryOptimisticMessage: (tempId: string) => Promise<Message>;\n  \n  /**\n   * Get optimistic messages for a conversation\n   */\n  getOptimisticMessages: (conversationId: string) => OptimisticMessage[];\n  \n  /**\n   * Clear optimistic messages for a conversation\n   */\n  clearOptimisticMessages: (conversationId: string) => void;\n  \n  /**\n   * Preload recent conversations\n   */\n  preloadRecentConversations: (recentConversationIds: string[]) => Promise<void>;\n  \n  /**\n   * Current performance metrics\n   */\n  performanceMetrics: PerformanceMetrics;\n  \n  /**\n   * Performance recommendations\n   */\n  performanceRecommendations: string[];\n  \n  /**\n   * Whether performance monitoring is enabled\n   */\n  isMonitoringEnabled: boolean;\n  \n  /**\n   * Toggle performance monitoring\n   */\n  toggleMonitoring: (enabled: boolean) => void;\n  \n  /**\n   * Reset performance metrics\n   */\n  resetMetrics: () => void;\n  \n  /**\n   * Get cache statistics\n   */\n  getCacheStats: () => {\n    size: number;\n    maxSize: number;\n    totalMessages: number;\n    conversations: string[];\n  };\n}\n\n/**\n * Hook for messaging performance optimization\n */\nexport function useMessagingPerformance(\n  customMessageCache?: MessageCache,\n  config?: Partial<OptimizationConfig>\n): MessagingPerformanceHookResult {\n  const api = useMessagingApi();\n  const optimizerRef = useRef<MessagingPerformanceOptimizer | null>(null);\n  const [performanceMetrics, setPerformanceMetrics] = useState<PerformanceMetrics>({\n    cacheHitRate: 0,\n    averageLoadTime: 0,\n    apiCallCount: 0,\n    cacheHits: 0,\n    cacheMisses: 0,\n    memoryUsage: 0,\n    optimisticUpdates: 0,\n    failedOptimisticUpdates: 0,\n    averageOptimisticConfirmTime: 0\n  });\n  const [performanceRecommendations, setPerformanceRecommendations] = useState<string[]>([]);\n  const [isMonitoringEnabled, setIsMonitoringEnabled] = useState(true);\n  const metricsUpdateInterval = useRef<NodeJS.Timeout | null>(null);\n  \n  // Initialize performance optimizer\n  useEffect(() => {\n    const cacheInstance = customMessageCache || messageCache;\n    optimizerRef.current = initializePerformanceOptimizer(cacheInstance, {\n      enablePerformanceMonitoring: isMonitoringEnabled,\n      ...config\n    });\n    \n    return () => {\n      if (optimizerRef.current) {\n        optimizerRef.current.destroy();\n        optimizerRef.current = null;\n      }\n    };\n  }, [customMessageCache, config, isMonitoringEnabled]);\n  \n  // Update metrics periodically\n  useEffect(() => {\n    if (isMonitoringEnabled && optimizerRef.current) {\n      const updateMetrics = () => {\n        if (optimizerRef.current) {\n          const metrics = optimizerRef.current.getMetrics();\n          setPerformanceMetrics(metrics);\n          \n          const recommendations = optimizerRef.current.getPerformanceRecommendations();\n          setPerformanceRecommendations(recommendations);\n        }\n      };\n      \n      // Update immediately\n      updateMetrics();\n      \n      // Set up periodic updates\n      metricsUpdateInterval.current = setInterval(updateMetrics, 30000); // Every 30 seconds\n      \n      return () => {\n        if (metricsUpdateInterval.current) {\n          clearInterval(metricsUpdateInterval.current);\n          metricsUpdateInterval.current = null;\n        }\n      };\n    }\n  }, [isMonitoringEnabled]);\n  \n  // Load messages with optimizations\n  const loadMessagesOptimized = useCallback(async (\n    conversationId: string,\n    options: {\n      useCache?: boolean;\n      enableOptimistic?: boolean;\n      batchKey?: string;\n    } = {}\n  ): Promise<Message[]> => {\n    if (!optimizerRef.current) {\n      throw new Error('Performance optimizer not initialized');\n    }\n    \n    return await optimizerRef.current.loadMessages(\n      conversationId,\n      () => api.getMessages(conversationId),\n      options\n    );\n  }, [api]);\n  \n  // Send message with optimistic updates\n  const sendMessageOptimistic = useCallback(async (\n    message: Omit<Message, '_id' | 'createdAt'>\n  ): Promise<Message> => {\n    if (!optimizerRef.current) {\n      throw new Error('Performance optimizer not initialized');\n    }\n    \n    return await optimizerRef.current.sendMessageOptimistic(\n      message,\n      (messageData) => api.sendMessage(messageData)\n    );\n  }, [api]);\n  \n  // Retry failed optimistic message\n  const retryOptimisticMessage = useCallback(async (tempId: string): Promise<Message> => {\n    if (!optimizerRef.current) {\n      throw new Error('Performance optimizer not initialized');\n    }\n    \n    return await optimizerRef.current.retryOptimisticMessage(\n      tempId,\n      (messageData) => api.sendMessage(messageData)\n    );\n  }, [api]);\n  \n  // Get optimistic messages for a conversation\n  const getOptimisticMessages = useCallback((conversationId: string): OptimisticMessage[] => {\n    if (!optimizerRef.current) {\n      return [];\n    }\n    \n    return optimizerRef.current.getOptimisticMessages(conversationId);\n  }, []);\n  \n  // Clear optimistic messages for a conversation\n  const clearOptimisticMessages = useCallback((conversationId: string): void => {\n    if (optimizerRef.current) {\n      optimizerRef.current.clearOptimisticMessages(conversationId);\n    }\n  }, []);\n  \n  // Preload recent conversations\n  const preloadRecentConversations = useCallback(async (recentConversationIds: string[]): Promise<void> => {\n    if (!optimizerRef.current) {\n      return;\n    }\n    \n    await optimizerRef.current.preloadRecentConversations(\n      async () => recentConversationIds,\n      async (conversationId) => {\n        const response = await api.getMessages(conversationId);\n        if (response.success && response.data) {\n          return response.data;\n        }\n        throw new Error(response.error?.message || 'Failed to load messages');\n      }\n    );\n  }, [api]);\n  \n  // Toggle performance monitoring\n  const toggleMonitoring = useCallback((enabled: boolean): void => {\n    setIsMonitoringEnabled(enabled);\n  }, []);\n  \n  // Reset performance metrics\n  const resetMetrics = useCallback((): void => {\n    if (optimizerRef.current) {\n      // Reinitialize optimizer to reset metrics\n      const cacheInstance = customMessageCache || messageCache;\n      optimizerRef.current.destroy();\n      optimizerRef.current = initializePerformanceOptimizer(cacheInstance, {\n        enablePerformanceMonitoring: isMonitoringEnabled,\n        ...config\n      });\n      \n      // Reset state\n      setPerformanceMetrics({\n        cacheHitRate: 0,\n        averageLoadTime: 0,\n        apiCallCount: 0,\n        cacheHits: 0,\n        cacheMisses: 0,\n        memoryUsage: 0,\n        optimisticUpdates: 0,\n        failedOptimisticUpdates: 0,\n        averageOptimisticConfirmTime: 0\n      });\n      setPerformanceRecommendations([]);\n    }\n  }, [customMessageCache, config, isMonitoringEnabled]);\n  \n  // Get cache statistics\n  const getCacheStats = useCallback(() => {\n    const cacheInstance = customMessageCache || messageCache;\n    return cacheInstance.getStats();\n  }, [customMessageCache]);\n  \n  return {\n    loadMessagesOptimized,\n    sendMessageOptimistic,\n    retryOptimisticMessage,\n    getOptimisticMessages,\n    clearOptimisticMessages,\n    preloadRecentConversations,\n    performanceMetrics,\n    performanceRecommendations,\n    isMonitoringEnabled,\n    toggleMonitoring,\n    resetMetrics,\n    getCacheStats\n  };\n}\n\n/**\n * Hook for performance monitoring only (lightweight)\n */\nexport function usePerformanceMonitoring(): {\n  metrics: PerformanceMetrics;\n  recommendations: string[];\n  cacheStats: {\n    size: number;\n    maxSize: number;\n    totalMessages: number;\n    conversations: string[];\n  } | null;\n} {\n  const [metrics, setMetrics] = useState<PerformanceMetrics>({\n    cacheHitRate: 0,\n    averageLoadTime: 0,\n    apiCallCount: 0,\n    cacheHits: 0,\n    cacheMisses: 0,\n    memoryUsage: 0,\n    optimisticUpdates: 0,\n    failedOptimisticUpdates: 0,\n    averageOptimisticConfirmTime: 0\n  });\n  const [recommendations, setRecommendations] = useState<string[]>([]);\n  const [cacheStats, setCacheStats] = useState<{\n    size: number;\n    maxSize: number;\n    totalMessages: number;\n    conversations: string[];\n  } | null>(null);\n  \n  useEffect(() => {\n    const updateMetrics = () => {\n      const optimizer = getPerformanceOptimizer();\n      if (optimizer) {\n        setMetrics(optimizer.getMetrics());\n        setRecommendations(optimizer.getPerformanceRecommendations());\n      }\n      \n      setCacheStats(messageCache.getStats());\n    };\n    \n    // Update immediately\n    updateMetrics();\n    \n    // Set up periodic updates\n    const interval = setInterval(updateMetrics, 30000); // Every 30 seconds\n    \n    return () => clearInterval(interval);\n  }, []);\n  \n  return {\n    metrics,\n    recommendations,\n    cacheStats\n  };\n}\n\n/**\n * Hook for optimistic message management\n */\nexport function useOptimisticMessages(conversationId: string): {\n  optimisticMessages: OptimisticMessage[];\n  sendOptimistic: (message: Omit<Message, '_id' | 'createdAt'>) => Promise<Message>;\n  retryMessage: (tempId: string) => Promise<Message>;\n  clearOptimistic: () => void;\n} {\n  const { \n    sendMessageOptimistic, \n    retryOptimisticMessage, \n    getOptimisticMessages, \n    clearOptimisticMessages \n  } = useMessagingPerformance();\n  const [optimisticMessages, setOptimisticMessages] = useState<OptimisticMessage[]>([]);\n  \n  // Update optimistic messages when conversation changes\n  useEffect(() => {\n    const updateOptimisticMessages = () => {\n      const messages = getOptimisticMessages(conversationId);\n      setOptimisticMessages(messages);\n    };\n    \n    updateOptimisticMessages();\n    \n    // Set up periodic updates to catch status changes\n    const interval = setInterval(updateOptimisticMessages, 1000);\n    \n    return () => clearInterval(interval);\n  }, [conversationId, getOptimisticMessages]);\n  \n  const sendOptimistic = useCallback(async (message: Omit<Message, '_id' | 'createdAt'>) => {\n    const result = await sendMessageOptimistic({\n      ...message,\n      conversationId\n    });\n    \n    // Update local state\n    setOptimisticMessages(getOptimisticMessages(conversationId));\n    \n    return result;\n  }, [conversationId, sendMessageOptimistic, getOptimisticMessages]);\n  \n  const retryMessage = useCallback(async (tempId: string) => {\n    const result = await retryOptimisticMessage(tempId);\n    \n    // Update local state\n    setOptimisticMessages(getOptimisticMessages(conversationId));\n    \n    return result;\n  }, [conversationId, retryOptimisticMessage, getOptimisticMessages]);\n  \n  const clearOptimistic = useCallback(() => {\n    clearOptimisticMessages(conversationId);\n    setOptimisticMessages([]);\n  }, [conversationId, clearOptimisticMessages]);\n  \n  return {\n    optimisticMessages,\n    sendOptimistic,\n    retryMessage,\n    clearOptimistic\n  };\n}"