import { useState, useEffect, useCallback, useRef } from 'react';\nimport { AppState } from 'react-native';\nimport { \n  OptimizedRealtimeService, \n  ConnectionPoolConfig, \n  ConnectionMetrics \n} from '../services/OptimizedRealtimeService';\nimport { \n  RealtimeMessage, \n  TypingIndicator, \n  DeliveryReceipt, \n  RealtimeEventHandlers \n} from '../services/RealtimeMessagingService';\nimport { useAuth } from '../contexts/AuthContext';\n\nexport interface OptimizedRealtimeHookResult {\n  /**\n   * Whether the service is connected\n   */\n  isConnected: boolean;\n  \n  /**\n   * Connection quality score (0-1)\n   */\n  connectionQuality: number;\n  \n  /**\n   * Current latency in milliseconds\n   */\n  latency: number;\n  \n  /**\n   * Send a message with priority\n   */\n  sendMessage: (message: any, priority?: 'high' | 'medium' | 'low') => void;\n  \n  /**\n   * Send typing indicator\n   */\n  sendTypingIndicator: (conversationId: string, isTyping: boolean) => void;\n  \n  /**\n   * Send delivery receipt\n   */\n  sendDeliveryReceipt: (\n    messageId: string,\n    conversationId: string,\n    status: 'sent' | 'delivered' | 'read'\n  ) => void;\n  \n  /**\n   * Join a conversation\n   */\n  joinConversation: (conversationId: string) => void;\n  \n  /**\n   * Leave a conversation\n   */\n  leaveConversation: (conversationId: string) => void;\n  \n  /**\n   * Get connection metrics\n   */\n  getMetrics: () => {\n    totalConnections: number;\n    activeConnections: number;\n    averageLatency: number;\n    totalBandwidth: { sent: number; received: number };\n    averageQualityScore: number;\n    queuedMessages: number;\n  };\n  \n  /**\n   * Update service configuration\n   */\n  updateConfig: (config: Partial<ConnectionPoolConfig>) => void;\n  \n  /**\n   * Reconnect all connections\n   */\n  reconnect: () => Promise<boolean>;\n  \n  /**\n   * Get detailed connection metrics\n   */\n  getDetailedMetrics: () => Map<string, ConnectionMetrics>;\n}\n\n/**\n * Hook for optimized real-time messaging with connection pooling and performance optimization\n */\nexport function useOptimizedRealtime(\n  endpoints: string[] = [],\n  config?: Partial<ConnectionPoolConfig>,\n  handlers?: RealtimeEventHandlers\n): OptimizedRealtimeHookResult {\n  const { user, getToken } = useAuth();\n  const serviceRef = useRef<OptimizedRealtimeService | null>(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [connectionQuality, setConnectionQuality] = useState(0);\n  const [latency, setLatency] = useState(0);\n  const [isInitialized, setIsInitialized] = useState(false);\n  const metricsUpdateInterval = useRef<NodeJS.Timeout | null>(null);\n  \n  // Initialize service\n  useEffect(() => {\n    if (!user || !endpoints.length) return;\n    \n    const initializeService = async () => {\n      try {\n        // Create service instance\n        serviceRef.current = new OptimizedRealtimeService(config);\n        \n        // Set up event handlers\n        const combinedHandlers: RealtimeEventHandlers = {\n          ...handlers,\n          onConnectionChange: (connected) => {\n            setIsConnected(connected);\n            handlers?.onConnectionChange?.(connected);\n          },\n          onError: (error) => {\n            console.error('Optimized realtime error:', error);\n            handlers?.onError?.(error);\n          }\n        };\n        \n        // Initialize with user ID and endpoints\n        const success = await serviceRef.current.initialize(\n          user.id,\n          combinedHandlers,\n          endpoints\n        );\n        \n        if (success) {\n          setIsInitialized(true);\n          startMetricsUpdates();\n        } else {\n          console.error('Failed to initialize optimized realtime service');\n        }\n      } catch (error) {\n        console.error('Error initializing optimized realtime service:', error);\n      }\n    };\n    \n    initializeService();\n    \n    return () => {\n      if (serviceRef.current) {\n        serviceRef.current.disconnect();\n        serviceRef.current = null;\n      }\n      \n      if (metricsUpdateInterval.current) {\n        clearInterval(metricsUpdateInterval.current);\n        metricsUpdateInterval.current = null;\n      }\n      \n      setIsInitialized(false);\n    };\n  }, [user, endpoints.join(','), JSON.stringify(config)]);\n  \n  // Start metrics updates\n  const startMetricsUpdates = useCallback(() => {\n    if (metricsUpdateInterval.current) {\n      clearInterval(metricsUpdateInterval.current);\n    }\n    \n    metricsUpdateInterval.current = setInterval(() => {\n      if (serviceRef.current) {\n        const metrics = serviceRef.current.getOverallMetrics();\n        setConnectionQuality(metrics.averageQualityScore);\n        setLatency(metrics.averageLatency);\n      }\n    }, 5000); // Update every 5 seconds\n  }, []);\n  \n  // Send message with priority\n  const sendMessage = useCallback((message: any, priority: 'high' | 'medium' | 'low' = 'medium') => {\n    if (serviceRef.current) {\n      serviceRef.current.sendMessage(message, priority);\n    }\n  }, []);\n  \n  // Send typing indicator\n  const sendTypingIndicator = useCallback((conversationId: string, isTyping: boolean) => {\n    if (serviceRef.current) {\n      serviceRef.current.sendTypingIndicator(conversationId, isTyping);\n    }\n  }, []);\n  \n  // Send delivery receipt\n  const sendDeliveryReceipt = useCallback((\n    messageId: string,\n    conversationId: string,\n    status: 'sent' | 'delivered' | 'read'\n  ) => {\n    if (serviceRef.current) {\n      serviceRef.current.sendDeliveryReceipt(messageId, conversationId, status);\n    }\n  }, []);\n  \n  // Join conversation\n  const joinConversation = useCallback((conversationId: string) => {\n    if (serviceRef.current) {\n      serviceRef.current.sendMessage({\n        type: 'join_conversation',\n        conversationId,\n        userId: user?.id\n      }, 'high');\n    }\n  }, [user]);\n  \n  // Leave conversation\n  const leaveConversation = useCallback((conversationId: string) => {\n    if (serviceRef.current) {\n      serviceRef.current.sendMessage({\n        type: 'leave_conversation',\n        conversationId,\n        userId: user?.id\n      }, 'medium');\n    }\n  }, [user]);\n  \n  // Get metrics\n  const getMetrics = useCallback(() => {\n    if (serviceRef.current) {\n      return serviceRef.current.getOverallMetrics();\n    }\n    \n    return {\n      totalConnections: 0,\n      activeConnections: 0,\n      averageLatency: 0,\n      totalBandwidth: { sent: 0, received: 0 },\n      averageQualityScore: 0,\n      queuedMessages: 0\n    };\n  }, []);\n  \n  // Update configuration\n  const updateConfig = useCallback((newConfig: Partial<ConnectionPoolConfig>) => {\n    if (serviceRef.current) {\n      serviceRef.current.updateConfig(newConfig);\n    }\n  }, []);\n  \n  // Reconnect\n  const reconnect = useCallback(async (): Promise<boolean> => {\n    if (!serviceRef.current || !user || !endpoints.length) {\n      return false;\n    }\n    \n    try {\n      // Disconnect current service\n      serviceRef.current.disconnect();\n      \n      // Create new service instance\n      serviceRef.current = new OptimizedRealtimeService(config);\n      \n      // Set up event handlers\n      const combinedHandlers: RealtimeEventHandlers = {\n        ...handlers,\n        onConnectionChange: (connected) => {\n          setIsConnected(connected);\n          handlers?.onConnectionChange?.(connected);\n        },\n        onError: (error) => {\n          console.error('Optimized realtime error:', error);\n          handlers?.onError?.(error);\n        }\n      };\n      \n      // Initialize with user ID and endpoints\n      const success = await serviceRef.current.initialize(\n        user.id,\n        combinedHandlers,\n        endpoints\n      );\n      \n      if (success) {\n        startMetricsUpdates();\n      }\n      \n      return success;\n    } catch (error) {\n      console.error('Error reconnecting optimized realtime service:', error);\n      return false;\n    }\n  }, [user, endpoints, config, handlers, startMetricsUpdates]);\n  \n  // Get detailed metrics\n  const getDetailedMetrics = useCallback((): Map<string, ConnectionMetrics> => {\n    if (serviceRef.current) {\n      return serviceRef.current.getConnectionMetrics();\n    }\n    return new Map();\n  }, []);\n  \n  // Handle app state changes\n  useEffect(() => {\n    const handleAppStateChange = (nextAppState: string) => {\n      if (nextAppState === 'active' && isInitialized && !isConnected) {\n        // App became active and we're not connected - try to reconnect\n        reconnect();\n      }\n    };\n    \n    const subscription = AppState.addEventListener('change', handleAppStateChange);\n    \n    return () => {\n      subscription?.remove();\n    };\n  }, [isInitialized, isConnected, reconnect]);\n  \n  return {\n    isConnected,\n    connectionQuality,\n    latency,\n    sendMessage,\n    sendTypingIndicator,\n    sendDeliveryReceipt,\n    joinConversation,\n    leaveConversation,\n    getMetrics,\n    updateConfig,\n    reconnect,\n    getDetailedMetrics\n  };\n}\n\n/**\n * Hook for monitoring real-time performance\n */\nexport function useRealtimePerformanceMonitor(): {\n  metrics: {\n    totalConnections: number;\n    activeConnections: number;\n    averageLatency: number;\n    totalBandwidth: { sent: number; received: number };\n    averageQualityScore: number;\n    queuedMessages: number;\n  } | null;\n  detailedMetrics: Map<string, ConnectionMetrics> | null;\n  recommendations: string[];\n} {\n  const [metrics, setMetrics] = useState<any>(null);\n  const [detailedMetrics, setDetailedMetrics] = useState<Map<string, ConnectionMetrics> | null>(null);\n  const [recommendations, setRecommendations] = useState<string[]>([]);\n  \n  // This would typically get metrics from a global service instance\n  // For now, return empty state\n  return {\n    metrics,\n    detailedMetrics,\n    recommendations\n  };\n}\n\n/**\n * Hook for voice message bandwidth optimization\n */\nexport function useVoiceBandwidthOptimization(): {\n  optimizeVoiceMessage: (audioBlob: Blob) => Promise<Blob>;\n  getOptimalBitrate: (networkQuality: number) => number;\n  shouldCompressVoice: (fileSize: number, networkQuality: number) => boolean;\n} {\n  const optimizeVoiceMessage = useCallback(async (audioBlob: Blob): Promise<Blob> => {\n    // This would implement voice compression based on network conditions\n    // For now, return the original blob\n    return audioBlob;\n  }, []);\n  \n  const getOptimalBitrate = useCallback((networkQuality: number): number => {\n    // Adjust bitrate based on network quality\n    if (networkQuality > 0.8) {\n      return 128; // High quality\n    } else if (networkQuality > 0.5) {\n      return 64; // Medium quality\n    } else {\n      return 32; // Low quality for poor connections\n    }\n  }, []);\n  \n  const shouldCompressVoice = useCallback((fileSize: number, networkQuality: number): boolean => {\n    // Compress if file is large or network quality is poor\n    const maxSize = networkQuality > 0.7 ? 5 * 1024 * 1024 : 2 * 1024 * 1024; // 5MB or 2MB\n    return fileSize > maxSize;\n  }, []);\n  \n  return {\n    optimizeVoiceMessage,\n    getOptimalBitrate,\n    shouldCompressVoice\n  };\n}"