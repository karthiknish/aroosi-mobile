import { EventEmitter } from 'events';\nimport { Platform, NetInfo } from 'react-native';\n\nexport interface WebSocketConnection {\n  id: string;\n  url: string;\n  ws: WebSocket;\n  state: 'connecting' | 'connected' | 'disconnected' | 'error';\n  lastActivity: number;\n  reconnectAttempts: number;\n  metrics: {\n    latency: number;\n    messagesPerSecond: number;\n    errorRate: number;\n    uptime: number;\n    bytesTransferred: number;\n  };\n}\n\nexport interface ConnectionManagerConfig {\n  maxConnections: number;\n  connectionTimeout: number;\n  maxReconnectAttempts: number;\n  reconnectDelay: number;\n  healthCheckInterval: number;\n  loadBalancingStrategy: 'round-robin' | 'least-latency' | 'least-load';\n  enableFailover: boolean;\n  compressionEnabled: boolean;\n}\n\nexport interface LoadBalancingStrategy {\n  selectConnection(connections: WebSocketConnection[]): WebSocketConnection | null;\n}\n\n/**\n * Round-robin load balancing strategy\n */\nclass RoundRobinStrategy implements LoadBalancingStrategy {\n  private currentIndex = 0;\n  \n  selectConnection(connections: WebSocketConnection[]): WebSocketConnection | null {\n    const activeConnections = connections.filter(conn => conn.state === 'connected');\n    if (activeConnections.length === 0) return null;\n    \n    const connection = activeConnections[this.currentIndex % activeConnections.length];\n    this.currentIndex = (this.currentIndex + 1) % activeConnections.length;\n    \n    return connection;\n  }\n}\n\n/**\n * Least latency load balancing strategy\n */\nclass LeastLatencyStrategy implements LoadBalancingStrategy {\n  selectConnection(connections: WebSocketConnection[]): WebSocketConnection | null {\n    const activeConnections = connections.filter(conn => conn.state === 'connected');\n    if (activeConnections.length === 0) return null;\n    \n    return activeConnections.reduce((best, current) => \n      current.metrics.latency < best.metrics.latency ? current : best\n    );\n  }\n}\n\n/**\n * Least load balancing strategy\n */\nclass LeastLoadStrategy implements LoadBalancingStrategy {\n  selectConnection(connections: WebSocketConnection[]): WebSocketConnection | null {\n    const activeConnections = connections.filter(conn => conn.state === 'connected');\n    if (activeConnections.length === 0) return null;\n    \n    return activeConnections.reduce((best, current) => \n      current.metrics.messagesPerSecond < best.metrics.messagesPerSecond ? current : best\n    );\n  }\n}\n\n/**\n * WebSocket Connection Manager with pooling and load balancing\n */\nexport class WebSocketConnectionManager extends EventEmitter {\n  private connections = new Map<string, WebSocketConnection>();\n  private config: ConnectionManagerConfig;\n  private loadBalancer: LoadBalancingStrategy;\n  private healthCheckTimer: NodeJS.Timeout | null = null;\n  private reconnectTimers = new Map<string, NodeJS.Timeout>();\n  private isNetworkAvailable = true;\n  private messageQueue: Array<{ message: any; priority: number }> = [];\n  \n  constructor(config: Partial<ConnectionManagerConfig> = {}) {\n    super();\n    \n    this.config = {\n      maxConnections: 3,\n      connectionTimeout: 10000,\n      maxReconnectAttempts: 5,\n      reconnectDelay: 1000,\n      healthCheckInterval: 30000,\n      loadBalancingStrategy: 'least-latency',\n      enableFailover: true,\n      compressionEnabled: true,\n      ...config\n    };\n    \n    this.loadBalancer = this.createLoadBalancer(this.config.loadBalancingStrategy);\n    this.setupNetworkMonitoring();\n    this.startHealthCheck();\n  }\n  \n  /**\n   * Create load balancer based on strategy\n   */\n  private createLoadBalancer(strategy: string): LoadBalancingStrategy {\n    switch (strategy) {\n      case 'round-robin':\n        return new RoundRobinStrategy();\n      case 'least-latency':\n        return new LeastLatencyStrategy();\n      case 'least-load':\n        return new LeastLoadStrategy();\n      default:\n        return new LeastLatencyStrategy();\n    }\n  }\n  \n  /**\n   * Add a WebSocket connection to the pool\n   */\n  async addConnection(id: string, url: string): Promise<boolean> {\n    if (this.connections.size >= this.config.maxConnections) {\n      console.warn('Maximum connections reached');\n      return false;\n    }\n    \n    if (this.connections.has(id)) {\n      console.warn(`Connection ${id} already exists`);\n      return false;\n    }\n    \n    try {\n      const connection = await this.createConnection(id, url);\n      this.connections.set(id, connection);\n      \n      console.log(`Connection ${id} added successfully`);\n      this.emit('connection_added', connection);\n      \n      return true;\n    } catch (error) {\n      console.error(`Failed to add connection ${id}:`, error);\n      return false;\n    }\n  }\n  \n  /**\n   * Create a WebSocket connection\n   */\n  private async createConnection(id: string, url: string): Promise<WebSocketConnection> {\n    return new Promise((resolve, reject) => {\n      const wsUrl = this.config.compressionEnabled \n        ? `${url}?compression=true` \n        : url;\n      \n      const ws = new WebSocket(wsUrl);\n      const startTime = Date.now();\n      \n      const connection: WebSocketConnection = {\n        id,\n        url,\n        ws,\n        state: 'connecting',\n        lastActivity: Date.now(),\n        reconnectAttempts: 0,\n        metrics: {\n          latency: 0,\n          messagesPerSecond: 0,\n          errorRate: 0,\n          uptime: 0,\n          bytesTransferred: 0\n        }\n      };\n      \n      // Connection timeout\n      const timeout = setTimeout(() => {\n        ws.close();\n        reject(new Error(`Connection timeout for ${id}`));\n      }, this.config.connectionTimeout);\n      \n      ws.onopen = () => {\n        clearTimeout(timeout);\n        connection.state = 'connected';\n        connection.metrics.uptime = Date.now();\n        \n        console.log(`WebSocket ${id} connected`);\n        this.emit('connection_opened', connection);\n        \n        resolve(connection);\n      };\n      \n      ws.onmessage = (event) => {\n        connection.lastActivity = Date.now();\n        connection.metrics.bytesTransferred += event.data.length;\n        \n        // Calculate latency if message has timestamp\n        try {\n          const data = JSON.parse(event.data);\n          if (data.timestamp) {\n            const latency = Date.now() - data.timestamp;\n            connection.metrics.latency = connection.metrics.latency * 0.8 + latency * 0.2;\n          }\n        } catch (e) {\n          // Ignore parsing errors for latency calculation\n        }\n        \n        this.emit('message', { connectionId: id, data: event.data });\n      };\n      \n      ws.onclose = (event) => {\n        clearTimeout(timeout);\n        connection.state = 'disconnected';\n        \n        console.log(`WebSocket ${id} disconnected:`, event.code, event.reason);\n        this.emit('connection_closed', { connection, event });\n        \n        // Schedule reconnection if not intentional\n        if (event.code !== 1000 && this.config.enableFailover) {\n          this.scheduleReconnection(connection);\n        }\n      };\n      \n      ws.onerror = (error) => {\n        clearTimeout(timeout);\n        connection.state = 'error';\n        connection.metrics.errorRate += 1;\n        \n        console.error(`WebSocket ${id} error:`, error);\n        this.emit('connection_error', { connection, error });\n        \n        reject(error);\n      };\n    });\n  }\n  \n  /**\n   * Remove a connection from the pool\n   */\n  removeConnection(id: string): boolean {\n    const connection = this.connections.get(id);\n    if (!connection) {\n      return false;\n    }\n    \n    // Clear reconnect timer if exists\n    const timer = this.reconnectTimers.get(id);\n    if (timer) {\n      clearTimeout(timer);\n      this.reconnectTimers.delete(id);\n    }\n    \n    // Close WebSocket\n    if (connection.ws.readyState === WebSocket.OPEN) {\n      connection.ws.close(1000, 'Connection removed');\n    }\n    \n    this.connections.delete(id);\n    this.emit('connection_removed', connection);\n    \n    console.log(`Connection ${id} removed`);\n    return true;\n  }\n  \n  /**\n   * Send message using load balancing\n   */\n  sendMessage(message: any, priority: number = 1): boolean {\n    if (!this.isNetworkAvailable) {\n      this.queueMessage(message, priority);\n      return false;\n    }\n    \n    const connection = this.loadBalancer.selectConnection(Array.from(this.connections.values()));\n    if (!connection) {\n      this.queueMessage(message, priority);\n      return false;\n    }\n    \n    try {\n      const messageStr = JSON.stringify({\n        ...message,\n        timestamp: Date.now()\n      });\n      \n      connection.ws.send(messageStr);\n      connection.lastActivity = Date.now();\n      connection.metrics.bytesTransferred += messageStr.length;\n      connection.metrics.messagesPerSecond += 1;\n      \n      return true;\n    } catch (error) {\n      console.error('Failed to send message:', error);\n      this.queueMessage(message, priority);\n      return false;\n    }\n  }\n  \n  /**\n   * Send message to specific connection\n   */\n  sendMessageToConnection(connectionId: string, message: any): boolean {\n    const connection = this.connections.get(connectionId);\n    if (!connection || connection.state !== 'connected') {\n      return false;\n    }\n    \n    try {\n      const messageStr = JSON.stringify({\n        ...message,\n        timestamp: Date.now()\n      });\n      \n      connection.ws.send(messageStr);\n      connection.lastActivity = Date.now();\n      connection.metrics.bytesTransferred += messageStr.length;\n      connection.metrics.messagesPerSecond += 1;\n      \n      return true;\n    } catch (error) {\n      console.error(`Failed to send message to ${connectionId}:`, error);\n      return false;\n    }\n  }\n  \n  /**\n   * Queue message for later sending\n   */\n  private queueMessage(message: any, priority: number): void {\n    this.messageQueue.push({ message, priority });\n    \n    // Sort by priority (higher priority first)\n    this.messageQueue.sort((a, b) => b.priority - a.priority);\n    \n    // Limit queue size\n    if (this.messageQueue.length > 1000) {\n      this.messageQueue = this.messageQueue.slice(0, 1000);\n    }\n  }\n  \n  /**\n   * Process queued messages\n   */\n  private processMessageQueue(): void {\n    while (this.messageQueue.length > 0) {\n      const { message, priority } = this.messageQueue.shift()!;\n      if (!this.sendMessage(message, priority)) {\n        // If sending fails, put it back at the front\n        this.messageQueue.unshift({ message, priority });\n        break;\n      }\n    }\n  }\n  \n  /**\n   * Schedule reconnection for a connection\n   */\n  private scheduleReconnection(connection: WebSocketConnection): void {\n    if (connection.reconnectAttempts >= this.config.maxReconnectAttempts) {\n      console.error(`Max reconnection attempts reached for ${connection.id}`);\n      this.emit('connection_failed', connection);\n      return;\n    }\n    \n    connection.reconnectAttempts++;\n    const delay = this.config.reconnectDelay * Math.pow(2, connection.reconnectAttempts - 1);\n    \n    console.log(`Scheduling reconnection for ${connection.id} in ${delay}ms`);\n    \n    const timer = setTimeout(async () => {\n      try {\n        const newConnection = await this.createConnection(connection.id, connection.url);\n        this.connections.set(connection.id, newConnection);\n        \n        console.log(`Connection ${connection.id} reconnected successfully`);\n        this.emit('connection_reconnected', newConnection);\n        \n        // Process queued messages\n        this.processMessageQueue();\n      } catch (error) {\n        console.error(`Reconnection failed for ${connection.id}:`, error);\n        this.scheduleReconnection(connection);\n      }\n    }, delay);\n    \n    this.reconnectTimers.set(connection.id, timer);\n  }\n  \n  /**\n   * Setup network monitoring\n   */\n  private setupNetworkMonitoring(): void {\n    NetInfo.addEventListener(state => {\n      const wasAvailable = this.isNetworkAvailable;\n      this.isNetworkAvailable = state.isConnected;\n      \n      if (!wasAvailable && this.isNetworkAvailable) {\n        console.log('Network restored - processing queued messages');\n        this.processMessageQueue();\n        this.emit('network_restored');\n      } else if (wasAvailable && !this.isNetworkAvailable) {\n        console.log('Network lost - queuing messages');\n        this.emit('network_lost');\n      }\n    });\n  }\n  \n  /**\n   * Start health check for all connections\n   */\n  private startHealthCheck(): void {\n    this.healthCheckTimer = setInterval(() => {\n      this.performHealthCheck();\n    }, this.config.healthCheckInterval);\n  }\n  \n  /**\n   * Perform health check on all connections\n   */\n  private performHealthCheck(): void {\n    const now = Date.now();\n    \n    for (const [id, connection] of this.connections.entries()) {\n      // Update uptime\n      if (connection.state === 'connected') {\n        connection.metrics.uptime = now - connection.metrics.uptime;\n      }\n      \n      // Reset messages per second counter\n      connection.metrics.messagesPerSecond = 0;\n      \n      // Check if connection is stale\n      const timeSinceLastActivity = now - connection.lastActivity;\n      if (timeSinceLastActivity > this.config.healthCheckInterval * 2) {\n        console.warn(`Connection ${id} appears stale, sending ping`);\n        this.sendPing(connection);\n      }\n      \n      // Check connection state\n      if (connection.ws.readyState === WebSocket.CLOSED) {\n        console.warn(`Connection ${id} is closed, scheduling reconnection`);\n        this.scheduleReconnection(connection);\n      }\n    }\n    \n    this.emit('health_check_completed', {\n      totalConnections: this.connections.size,\n      activeConnections: this.getActiveConnectionCount(),\n      queuedMessages: this.messageQueue.length\n    });\n  }\n  \n  /**\n   * Send ping to connection\n   */\n  private sendPing(connection: WebSocketConnection): void {\n    if (connection.state === 'connected') {\n      try {\n        connection.ws.send(JSON.stringify({ type: 'ping', timestamp: Date.now() }));\n      } catch (error) {\n        console.error(`Failed to send ping to ${connection.id}:`, error);\n      }\n    }\n  }\n  \n  /**\n   * Get number of active connections\n   */\n  getActiveConnectionCount(): number {\n    return Array.from(this.connections.values())\n      .filter(conn => conn.state === 'connected').length;\n  }\n  \n  /**\n   * Get connection by ID\n   */\n  getConnection(id: string): WebSocketConnection | undefined {\n    return this.connections.get(id);\n  }\n  \n  /**\n   * Get all connections\n   */\n  getAllConnections(): WebSocketConnection[] {\n    return Array.from(this.connections.values());\n  }\n  \n  /**\n   * Get connection metrics\n   */\n  getConnectionMetrics(): Map<string, WebSocketConnection['metrics']> {\n    const metrics = new Map<string, WebSocketConnection['metrics']>();\n    \n    for (const [id, connection] of this.connections.entries()) {\n      metrics.set(id, { ...connection.metrics });\n    }\n    \n    return metrics;\n  }\n  \n  /**\n   * Get overall statistics\n   */\n  getStatistics(): {\n    totalConnections: number;\n    activeConnections: number;\n    averageLatency: number;\n    totalBytesTransferred: number;\n    queuedMessages: number;\n    networkAvailable: boolean;\n  } {\n    const connections = Array.from(this.connections.values());\n    const activeConnections = connections.filter(conn => conn.state === 'connected');\n    \n    const averageLatency = activeConnections.length > 0\n      ? activeConnections.reduce((sum, conn) => sum + conn.metrics.latency, 0) / activeConnections.length\n      : 0;\n    \n    const totalBytesTransferred = connections\n      .reduce((sum, conn) => sum + conn.metrics.bytesTransferred, 0);\n    \n    return {\n      totalConnections: connections.length,\n      activeConnections: activeConnections.length,\n      averageLatency,\n      totalBytesTransferred,\n      queuedMessages: this.messageQueue.length,\n      networkAvailable: this.isNetworkAvailable\n    };\n  }\n  \n  /**\n   * Update configuration\n   */\n  updateConfig(config: Partial<ConnectionManagerConfig>): void {\n    this.config = { ...this.config, ...config };\n    \n    // Update load balancer if strategy changed\n    if (config.loadBalancingStrategy) {\n      this.loadBalancer = this.createLoadBalancer(config.loadBalancingStrategy);\n    }\n    \n    // Restart health check if interval changed\n    if (config.healthCheckInterval && this.healthCheckTimer) {\n      clearInterval(this.healthCheckTimer);\n      this.startHealthCheck();\n    }\n  }\n  \n  /**\n   * Disconnect all connections and cleanup\n   */\n  disconnect(): void {\n    // Clear health check timer\n    if (this.healthCheckTimer) {\n      clearInterval(this.healthCheckTimer);\n      this.healthCheckTimer = null;\n    }\n    \n    // Clear all reconnect timers\n    for (const timer of this.reconnectTimers.values()) {\n      clearTimeout(timer);\n    }\n    this.reconnectTimers.clear();\n    \n    // Close all connections\n    for (const connection of this.connections.values()) {\n      if (connection.ws.readyState === WebSocket.OPEN) {\n        connection.ws.close(1000, 'Manager shutdown');\n      }\n    }\n    \n    this.connections.clear();\n    this.messageQueue = [];\n    \n    // Remove all listeners\n    this.removeAllListeners();\n    \n    console.log('WebSocket Connection Manager disconnected');\n  }\n}"